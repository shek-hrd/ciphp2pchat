<script>
/* =========================================================================
   CONFIG: change to your Render service URL once
   ========================================================================= */
const RELAY_HOST = 'chat-relay-zim2.onrender.com';   // <-- FIX
const RELAY_WS   = `wss://${RELAY_HOST}`;
const RELAY_PING = `https://${RELAY_HOST}/ping`;
const RELAY_BLOB = `https://${RELAY_HOST}/dummy256k.bin`;

/* =========================================================================
   0.  Helpers
   ========================================================================= */
const $ = id => document.getElementById(id);
const log = txt => { logEl.textContent += txt + '\n'; logEl.scrollTop = 1e9; };
const logEl = $('log');

/* =========================================================================
   1.  IndexedDB wrappers
   ========================================================================= */
const DB_NAME = 'chatcache', STORE_NAME = 'keys';
async function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onerror = () => reject(req.error);
    req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
    req.onsuccess = () => resolve(req.result);
  });
}
async function dbPut(k, v) { const db=await openDB(); return new Promise((r,x)=>{const t=db.transaction(STORE_NAME,'readwrite');t.objectStore(STORE_NAME).put(v,k).onerror=x; t.oncomplete=r;});}
async function dbGet(k)   { const db=await openDB(); return new Promise((r,x)=>{const t=db.transaction(STORE_NAME,'readonly');const q=t.objectStore(STORE_NAME).get(k); q.onerror=x; q.onsuccess=()=>r(q.result);});}

/* =========================================================================
   2.  Fingerprint — skips Audio until user gesture
   ========================================================================= */
let audioCtx;
function initAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}
async function fingerprint() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.textBaseline = 'top'; ctx.font = '14px Arial'; ctx.fillText('fp', 2, 2);
  const canvasHash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(canvas.toDataURL()));

  // Audio only after user gesture
  initAudioCtx();
  const osc = audioCtx.createOscillator();
  const dest = audioCtx.createMediaStreamDestination();
  osc.connect(dest); osc.start();
  const buf = new Float32Array(44100);
  const audioHash = await crypto.subtle.digest('SHA-256', buf.buffer);
  osc.stop();

  const str = [
    new Uint8Array(canvasHash).reduce((a,b)=>a+b.toString(16).padStart(2,'0'),''),
    new Uint8Array(audioHash).reduce((a,b)=>a+b.toString(16).padStart(2,'0'),''),
    navigator.userAgent,
    screen.width, screen.height, screen.colorDepth,
    navigator.hardwareConcurrency || 0,
    Intl.DateTimeFormat().resolvedOptions().timeZone
  ].join('|');
  return Array.from(new Uint8Array(await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str))))
              .map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* =========================================================================
   3.  Crypto
   ========================================================================= */
async function genKeyPair() {
  return crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, false, ['deriveKey']);
}
async function deriveShared(priv, pub) {
  return crypto.subtle.deriveKey({name:'ECDH', public:pub}, priv, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
}
async function encrypt(key, text) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, new TextEncoder().encode(text)));
  return btoa(String.fromCharCode(...iv, ...ct));
}
async function decrypt(key, blob) {
  const bytes = new Uint8Array(atob(blob).split('').map(c=>c.charCodeAt(0)));
  const iv = bytes.slice(0,12), ct = bytes.slice(12);
  return new TextDecoder().decode(await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct));
}

/* =========================================================================
   4.  Network metrics — against Render host
   ========================================================================= */
async function measureMetrics() {
  let rtt = 0, bw = 0;
  try {
    const t0 = performance.now();
    await fetch(RELAY_PING);
    rtt = Math.round(performance.now() - t0);
  } catch { /* ignore */ }
  try {
    const t1 = performance.now();
    const resp = await fetch(RELAY_BLOB);
    if (resp.ok) await resp.arrayBuffer();
    bw = Math.round(256 / ((performance.now() - t1)/1000)); // kB/s
  } catch { /* ignore */ }
  return {rtt, bw};
}

/* =========================================================================
   5.  Boot
   ========================================================================= */
let me, peers = new Map(), ws;

// Defer everything until first click (satisfies Audio policy)
document.addEventListener('click', async () => {
  if (ws) return; // run once
  const stamp = await fingerprint();
  const cached = await dbGet('identity');
  if (cached && cached.stamp === stamp) {
    me = cached;
  } else {
    const kp = await genKeyPair();
    const pubJwk = await crypto.subtle.exportKey('jwk', kp.publicKey);
    me = {stamp, pub:pubJwk, priv:kp.privateKey};
    await dbPut('identity', me);
  }

  const {rtt, bw} = await measureMetrics();
  log(`Stamp : ${me.stamp}`);
  log(`RTT   : ${rtt} ms`);
  log(`BW    : ${bw} kB/s`);

  ws = new WebSocket(RELAY_WS);
  ws.onopen = () => ws.send(JSON.stringify({type:'join', id:me.stamp, pub:me.pub}));
  ws.onmessage = async evt => {
    const {type, from, payload} = JSON.parse(evt.data);
    if (type === 'peerlist') {
      peers.clear();
      payload.forEach(p => peers.set(p.id, p.pub));
      log(`👥 ${peers.size} peers online`);
    }
    if (type === 'msg') {
      const pub = await crypto.subtle.importKey('jwk', peers.get(from), {name:'ECDH', namedCurve:'P-256'}, false, []);
      const shared = await deriveShared(me.priv, pub);
      const text = await decrypt(shared, payload);
      log(`💬 ${from.slice(0,8)}… : ${text}`);
    }
  };
  ws.onclose = () => log('❌ Disconnected');
}, {once:true});

/* =========================================================================
   6.  Send
   ========================================================================= */
async function send() {
  const text = $('msg').value.trim(); if (!text) return;
  $('msg').value = '';
  for (const [id, pubJwk] of peers) {
    const pub = await crypto.subtle.importKey('jwk', pubJwk, {name:'ECDH', namedCurve:'P-256'}, false, []);
    const shared = await deriveShared(me.priv, pub);
    const enc = await encrypt(shared, text);
    ws.send(JSON.stringify({type:'relay', to:id, payload:enc}));
  }
  log(`✉️ You: ${text}`);
}
// Wait until DOM is ready, then attach listener
window.addEventListener('DOMContentLoaded', () => {
  $('msg').addEventListener('keydown', e => e.key === 'Enter' && send());
});
</script>