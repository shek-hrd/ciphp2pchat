<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Lightweight P2P-Encrypted Chat</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 1rem; background:#f5f5f5}
    #log { background:#fff; border:1px solid #ccc; height:60vh; overflow-y:auto; padding:.5rem; white-space:pre-wrap; font-family:monospace }
    input { width:80%; padding:.5rem }
    button { padding:.5rem 1rem }
  </style>
</head>
<body>

<h1>Lightweight Encrypted Chat</h1>
<div id="log">🔌 Connecting…</div>
<input id="msg" placeholder="type & press Enter" autocomplete="off"/>
<button onclick="send()">Send</button>

<script>
/* =========================================================================
   0.  Tiny helpers
   ========================================================================= */
const $ = id => document.getElementById(id);
const log = txt => { logEl.textContent += txt + '\n'; logEl.scrollTop = 1e9; };
const logEl = $('log');

/* =========================================================================
   1.  Persistent key storage wrappers
   ========================================================================= */
const DB_NAME = 'chatcache';
const STORE_NAME = 'keys';
async function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onerror = () => reject(req.error);
    req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
    req.onsuccess = () => resolve(req.result);
  });
}
async function dbPut(key, val) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const req = tx.objectStore(STORE_NAME).put(val, key);
    req.onerror = () => reject(req.error);
    req.onsuccess = () => resolve();
  });
}
async function dbGet(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const req = db.transaction(STORE_NAME, 'readonly').objectStore(STORE_NAME).get(key);
    req.onerror = () => reject(req.error);
    req.onsuccess = () => resolve(req.result);
  });
}

/* =========================================================================
   2.  Fingerprint generator (canvas + audio + UA)
   ========================================================================= */
async function fingerprint() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.textBaseline = 'top';
  ctx.font = '14px Arial';
  ctx.fillText('fingerprint', 2, 2);
  const canvasHash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(canvas.toDataURL()));

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = audioCtx.createOscillator();
  const dst = audioCtx.createMediaStreamDestination();
  osc.connect(dst);
  osc.start();
  const buf = new Float32Array(44100);
  const p = dst.stream.getAudioTracks()[0].getSettings().sampleRate;
  const audioHash = await crypto.subtle.digest('SHA-256', buf.buffer);
  const str = [
    new Uint8Array(canvasHash).reduce((a,b)=>a+b.toString(16).padStart(2,'0'),''),
    new Uint8Array(audioHash).reduce((a,b)=>a+b.toString(16).padStart(2,'0'),''),
    navigator.userAgent,
    screen.width, screen.height, screen.colorDepth,
    navigator.hardwareConcurrency || 0,
    Intl.DateTimeFormat().resolvedOptions().timeZone
  ].join('|');
  return Array.from(new Uint8Array(await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str))))
              .map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* =========================================================================
   3.  Crypto helpers (ECDH + AES-GCM)
   ========================================================================= */
async function genKeyPair() {
  return crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, false, ['deriveKey']);
}
async function deriveShared(priv, pub) {
  return crypto.subtle.deriveKey(
    {name:'ECDH', public: pub},
    priv,
    {name:'AES-GCM', length:256},
    false,
    ['encrypt','decrypt']
  );
}
async function encrypt(key, plaintext) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, new TextEncoder().encode(plaintext)));
  return btoa(String.fromCharCode(...iv, ...ct));
}
async function decrypt(key, blob) {
  const bytes = new Uint8Array(atob(blob).split('').map(c=>c.charCodeAt(0)));
  const iv = bytes.slice(0,12);
  const ct = bytes.slice(12);
  const dec = new TextDecoder().decode(await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct));
  return dec;
}

/* =========================================================================
   4.  Network metrics (RTT & bandwidth)
   ========================================================================= */
async function measureMetrics() {
  // RTT: measure time to GET /ping endpoint
  const t0 = performance.now();
  await fetch('./ping');
  const rtt = Math.round(performance.now() - t0);

  // Bandwidth: download 256 kB dummy file
  const t1 = performance.now();
  const resp = await fetch('./dummy256k.bin');
  await resp.arrayBuffer();
  const bw = Math.round(256 / ((performance.now() - t1)/1000)); // kB/s
  return {rtt, bw};
}

/* =========================================================================
   5.  Boot sequence
   ========================================================================= */
let me, peers = new Map(), ws;
async function boot() {
  // 5a. load or create identity
  const stamp = await fingerprint();
  const cached = await dbGet('identity');
  if (cached && cached.stamp === stamp) {
    me = cached;
  } else {
    const keyPair = await genKeyPair();
    const pubJwk = await crypto.subtle.exportKey('jwk', keyPair.publicKey);
    me = {stamp, pub: pubJwk, priv: keyPair.privateKey};
    await dbPut('identity', me);
  }

  // 5b. metrics
  const {rtt, bw} = await measureMetrics();
  log(`Stamp  : ${me.stamp}`);
  log(`RTT    : ${rtt} ms`);
  log(`BW     : ${bw} kB/s`);

  // 5c. websocket to relay
  ws = new WebSocket(`wss://chat-relay-zim2.onrender.com`);
  ws.onopen = () => ws.send(JSON.stringify({type:'join', id:me.stamp, pub:me.pub}));
  ws.onmessage = onMsg;
  ws.onclose   = () => log('❌ Disconnected');
}
boot();

/* =========================================================================
   6.  Messaging
   ========================================================================= */
async function onMsg(evt) {
  const {type, from, payload} = JSON.parse(evt.data);
  if (type === 'peerlist') {
    peers.clear();
    payload.forEach(p => peers.set(p.id, p.pub));
    log(`👥 ${peers.size} peers online`);
    return;
  }
  if (type === 'msg') {
    const pub = await crypto.subtle.importKey('jwk', peers.get(from), {name:'ECDH', namedCurve:'P-256'}, false, []);
    const shared = await deriveShared(me.priv, pub);
    const text = await decrypt(shared, payload);
    log(`💬 ${from.slice(0,8)}… : ${text}`);
  }
}

async function send() {
  const text = $('msg').value.trim();
  if (!text) return;
  $('msg').value = '';
  // broadcast to each peer
  for (const [id, pubJwk] of peers) {
    const pub = await crypto.subtle.importKey('jwk', pubJwk, {name:'ECDH', namedCurve:'P-256'}, false, []);
    const shared = await deriveShared(me.priv, pub);
    const enc = await encrypt(shared, text);
    ws.send(JSON.stringify({type:'relay', to:id, payload:enc}));
  }
  log(`✉️ You: ${text}`);
}

// Enter to send
$('msg').addEventListener('keydown', e => e.key === 'Enter' && send());
</script>
</body>
</html>